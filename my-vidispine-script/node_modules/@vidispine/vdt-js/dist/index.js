'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var sortTimespanList = function sortTimespanList(_ref, _ref2) {
  var firstStart = _ref.start;
  var secondStart = _ref2.start;

  var _firstStart$split = firstStart.split('@'),
      _firstStart$split2 = _slicedToArray(_firstStart$split, 1),
      first = _firstStart$split2[0];

  var _secondStart$split = secondStart.split('@'),
      _secondStart$split2 = _slicedToArray(_secondStart$split, 1),
      second = _secondStart$split2[0];

  if (Number(first) < Number(second)) {
    return -1;
  }

  if (Number(first) > Number(second)) {
    return 1;
  }

  return 0;
};

var findTimespan = function findTimespan() {
  var metadataType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var start = arguments.length > 1 ? arguments[1] : undefined;
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var _metadataType$timespa = metadataType.timespan,
      timespanList = _metadataType$timespa === void 0 ? [] : _metadataType$timespa;
  return timespanList.find(function (timespan) {
    return timespan.start === start && timespan.end === end;
  });
};

var parseValueList = function parseValueList() {
  var valueList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$arrayOnSingl = options.arrayOnSingle,
      arrayOnSingle = _options$arrayOnSingl === void 0 ? true : _options$arrayOnSingl,
      _options$arrayOnSingl2 = options.arrayOnSingleValue,
      arrayOnSingleValue = _options$arrayOnSingl2 === void 0 ? true : _options$arrayOnSingl2,
      joinValue = options.joinValue,
      includeAttributes = options.includeAttributes,
      includeValueAttributes = options.includeValueAttributes;
  if (includeAttributes || includeValueAttributes) return valueList;
  var valueArray = [];
  valueList.forEach(function (thisValue) {
    if (thisValue.value) valueArray.push(thisValue.value);
  });
  if (joinValue) return valueArray.join(joinValue);

  if ((arrayOnSingle === false || arrayOnSingleValue === false) && valueArray.length === 1) {
    return valueArray[0];
  }

  return valueArray;
};

var parseField = function parseField() {
  var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var includeAttributes = options.includeAttributes,
      includeFieldAttributes = options.includeFieldAttributes;

  var _field$value = field.value,
      value = _field$value === void 0 ? [] : _field$value,
      attributes = _objectWithoutProperties(field, ["value"]);

  var parsedValueList = parseValueList(value, options);
  if (includeAttributes || includeFieldAttributes) return _objectSpread2(_objectSpread2({}, attributes), {}, {
    value: parsedValueList
  });
  return parsedValueList;
};

var parseFieldList = function parseFieldList() {
  var fieldList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var joinValue = options.joinValue,
      includeAttributes = options.includeAttributes,
      includeFieldAttributes = options.includeFieldAttributes,
      includeValueAttributes = options.includeValueAttributes;
  var output = {};
  var fieldAsList = options.fieldAsList;

  if (fieldAsList) {
    return fieldList.map(function (thisField) {
      return parseField(thisField, options);
    });
  }

  fieldList.forEach(function (thisField) {
    var key = thisField.name;
    var parsedField = parseField(thisField, options);

    if (output[key]) {
      if (includeAttributes || includeFieldAttributes) {
        var currentValue = output[key].value;
        var parsedValue = parsedField.value;

        if (joinValue && !includeAttributes && !includeValueAttributes) {
          output[key].value = [currentValue, parsedValue].join(joinValue);
        } else {
          output[key].value = parsedValue.concat(currentValue);
        }
      } else {
        var _currentValue = output[key];
        var _parsedValue = parsedField;

        if (joinValue) {
          output[key] = [_currentValue, _parsedValue].join(joinValue);
        } else {
          output[key] = _parsedValue.concat(_currentValue);
        }
      }
    } else {
      output[key] = parsedField;
    }
  });
  return output;
};

var parseGroup = function parseGroup() {
  var group = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var includeAttributes = options.includeAttributes,
      includeGroupAttributes = options.includeGroupAttributes,
      flat = options.flat,
      flatGroup = options.flatGroup,
      groupAsList = options.groupAsList,
      fieldAsList = options.fieldAsList;

  var _group$field = group.field,
      fieldList = _group$field === void 0 ? [] : _group$field,
      _group$group = group.group,
      groupList = _group$group === void 0 ? [] : _group$group,
      attributes = _objectWithoutProperties(group, ["field", "group"]);

  var parsedFieldList = parseFieldList(fieldList, options);
  var parsedGroupList = parseGroupList(groupList, options); // eslint-disable-line no-use-before-define,max-len

  var output = {};

  if (includeAttributes || includeGroupAttributes) {
    Object.assign(output, attributes);
  }

  if (flat || flatGroup) {
    if (groupAsList) {
      Object.assign(output, {
        group: parsedGroupList
      });
    } else {
      Object.assign(output, parsedGroupList);
    }

    if (fieldAsList) {
      Object.assign(output, {
        field: parsedFieldList
      });
    } else {
      Object.assign(output, parsedFieldList);
    }
  } else {
    Object.assign(output, {
      field: parsedFieldList
    });
    Object.assign(output, {
      group: parsedGroupList
    });
  }

  return output;
};

var parseGroupList = function parseGroupList() {
  var groupList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var groupAsList = options.groupAsList;

  if (groupAsList) {
    return groupList.map(function (thisGroup) {
      return parseGroup(thisGroup, options);
    });
  }

  var output = {};
  groupList.forEach(function (thisGroup) {
    var key = thisGroup.name;
    var parsedGroup = parseGroup(thisGroup, options);

    if (output[key]) {
      var _output$key = output[key],
          currentField = _output$key.field,
          currentGroup = _output$key.group;
      var parsedField = parsedGroup.field,
          parsedGroupList = parsedGroup.group;
      output[key].field = _objectSpread2(_objectSpread2({}, currentField), parsedField);
      output[key].group = _objectSpread2(_objectSpread2({}, currentGroup), parsedGroupList);
    } else {
      output[key] = parsedGroup;
    }
  });
  return output;
};

var parseTimespan = function parseTimespan() {
  var timespan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var includeAttributes = options.includeAttributes,
      includeTimespanAttributes = options.includeTimespanAttributes,
      flat = options.flat,
      flatTimespan = options.flatTimespan,
      groupAsList = options.groupAsList,
      fieldAsList = options.fieldAsList;

  var _timespan$field = timespan.field,
      fieldList = _timespan$field === void 0 ? [] : _timespan$field,
      _timespan$group = timespan.group,
      groupList = _timespan$group === void 0 ? [] : _timespan$group,
      attributes = _objectWithoutProperties(timespan, ["field", "group"]);

  var field = parseFieldList(fieldList, options);
  var group = parseGroupList(groupList, options);
  var output = {};

  if (includeAttributes || includeTimespanAttributes) {
    Object.assign(output, attributes);
  }

  if (flat || flatTimespan) {
    if (groupAsList) {
      Object.assign(output, {
        group: group
      });
    } else {
      Object.assign(output, group);
    }

    if (fieldAsList) {
      Object.assign(output, {
        field: field
      });
    } else {
      Object.assign(output, field);
    }
  } else {
    Object.assign(output, {
      field: field
    });
    Object.assign(output, {
      group: group
    });
  }

  return output;
};

var parseTimespanList = function parseTimespanList() {
  var timespanList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var joinTimespan = options.joinTimespan,
      flat = options.flat;
  var timespanAsList = options.timespanAsList;

  if (timespanAsList) {
    return timespanList.map(function (thisTimespan) {
      return parseTimespan(thisTimespan, options);
    });
  }

  var output = {};
  timespanList.forEach(function (thisTimespan) {
    var start = thisTimespan.start,
        end = thisTimespan.end;
    var key = [start, end].join(joinTimespan || '_');
    var parsedTimespan = parseTimespan(thisTimespan, options);

    if (flat) {
      output = _objectSpread2(_objectSpread2({}, output), parsedTimespan);
    } else if (output[key]) {
      var _output$key2 = output[key],
          currentField = _output$key2.field,
          currentGroup = _output$key2.group;
      var parsedField = parsedTimespan.field,
          parsedGroup = parsedTimespan.group;
      output[key].field = _objectSpread2(_objectSpread2({}, currentField), parsedField);
      output[key].group = _objectSpread2(_objectSpread2({}, currentGroup), parsedGroup);
    } else {
      output[key] = parsedTimespan;
    }
  });
  return output;
};
/**
 * Parses MetadataType into key/value object.
 * The attributes can be targeted for each sub-type.
 * @param {Object} metadataType - The response from the API.
 * @param {Object} options - Options which change how the metadataType is parsed.
 * @param {Object} options.joinValue - String to join the values, eg ','.
 * @param {Object} options.includeAttributes - include attributes on all objects.
 * @param {Object} options.includeMetadataAttributes - include attributes on root.
 * @param {Object} options.includeTimespanAttributes - include attributes on timespans.
 * @param {Object} options.includeGroupAttributes - include attributes on groups.
 * @param {Object} options.includeFieldAttributes - include attributes on fields.
 * @param {Object} options.includeValueAttributes - include attributes on values.
 * @param {Object} options.flat - Flatten to key/value (Note: keys may be overwritten).
 * @param {Object} options.flatTimespan - Flatten timespan.
 * @param {Object} options.flatGroup - Flatten group.
 * @param {Object} options.sortTimespan - Sort timespan by start time.
 * @param {Object} options.timespanAsList -Return timespans as list.
 * @param {Object} options.groupAsList -Return groups as list.
 * @param {Object} options.fieldAsList -Return fields as list.
 */


var parseMetadataType = function parseMetadataType() {
  var metadataType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var includeAttributes = options.includeAttributes,
      includeMetadataAttributes = options.includeMetadataAttributes,
      sortTimespan = options.sortTimespan;

  var _metadataType$timespa2 = metadataType.timespan,
      timespanList = _metadataType$timespa2 === void 0 ? [] : _metadataType$timespa2,
      attributes = _objectWithoutProperties(metadataType, ["timespan"]);

  if (sortTimespan) timespanList.sort(sortTimespanList);
  var timespan = parseTimespanList(timespanList, options);

  if (includeAttributes || includeMetadataAttributes) {
    Object.assign(timespan, attributes);
  }

  return timespan;
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var filesize = createCommonjsModule(function (module, exports) {
  /**
   * filesize
   *
   * @copyright 2020 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 6.1.0
   */

  (function (global) {
    var b = /^(b|B)$/,
        symbol = {
      iec: {
        bits: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"],
        bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
      },
      jedec: {
        bits: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
        bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
      }
    },
        fullform = {
      iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
      jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
    };
    /**
     * filesize
     *
     * @method filesize
     * @param  {Mixed}   arg        String, Int or Float to transform
     * @param  {Object}  descriptor [Optional] Flags
     * @return {String}             Readable file size String
     */

    function filesize(arg) {
      var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var result = [],
          val = 0,
          e = void 0,
          base = void 0,
          bits = void 0,
          ceil = void 0,
          full = void 0,
          fullforms = void 0,
          locale = void 0,
          localeOptions = void 0,
          neg = void 0,
          num = void 0,
          output = void 0,
          round = void 0,
          unix = void 0,
          separator = void 0,
          spacer = void 0,
          standard = void 0,
          symbols = void 0;

      if (isNaN(arg)) {
        throw new TypeError("Invalid number");
      }

      bits = descriptor.bits === true;
      unix = descriptor.unix === true;
      base = descriptor.base || 2;
      round = descriptor.round !== void 0 ? descriptor.round : unix ? 1 : 2;
      locale = descriptor.locale !== void 0 ? descriptor.locale : "";
      localeOptions = descriptor.localeOptions || {};
      separator = descriptor.separator !== void 0 ? descriptor.separator : "";
      spacer = descriptor.spacer !== void 0 ? descriptor.spacer : unix ? "" : " ";
      symbols = descriptor.symbols || {};
      standard = base === 2 ? descriptor.standard || "jedec" : "jedec";
      output = descriptor.output || "string";
      full = descriptor.fullform === true;
      fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];
      e = descriptor.exponent !== void 0 ? descriptor.exponent : -1;
      num = Number(arg);
      neg = num < 0;
      ceil = base > 2 ? 1000 : 1024; // Flipping a negative number to determine the size

      if (neg) {
        num = -num;
      } // Determining the exponent


      if (e === -1 || isNaN(e)) {
        e = Math.floor(Math.log(num) / Math.log(ceil));

        if (e < 0) {
          e = 0;
        }
      } // Exceeding supported length, time to reduce & multiply


      if (e > 8) {
        e = 8;
      }

      if (output === "exponent") {
        return e;
      } // Zero is now a special case because bytes divide by 1


      if (num === 0) {
        result[0] = 0;
        result[1] = unix ? "" : symbol[standard][bits ? "bits" : "bytes"][e];
      } else {
        val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));

        if (bits) {
          val = val * 8;

          if (val >= ceil && e < 8) {
            val = val / ceil;
            e++;
          }
        }

        result[0] = Number(val.toFixed(e > 0 ? round : 0));

        if (result[0] === ceil && e < 8 && descriptor.exponent === void 0) {
          result[0] = 1;
          e++;
        }

        result[1] = base === 10 && e === 1 ? bits ? "kb" : "kB" : symbol[standard][bits ? "bits" : "bytes"][e];

        if (unix) {
          result[1] = standard === "jedec" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, "") : result[1];

          if (b.test(result[1])) {
            result[0] = Math.floor(result[0]);
            result[1] = "";
          }
        }
      } // Decorating a 'diff'


      if (neg) {
        result[0] = -result[0];
      } // Applying custom symbol


      result[1] = symbols[result[1]] || result[1];

      if (locale === true) {
        result[0] = result[0].toLocaleString();
      } else if (locale.length > 0) {
        result[0] = result[0].toLocaleString(locale, localeOptions);
      } else if (separator.length > 0) {
        result[0] = result[0].toString().replace(".", separator);
      } // Returning Array, Object, or String (default)


      if (output === "array") {
        return result;
      }

      if (full) {
        result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? "bit" : "byte") + (result[0] === 1 ? "" : "s");
      }

      if (output === "object") {
        return {
          value: result[0],
          symbol: result[1],
          exponent: e
        };
      }

      return result.join(spacer);
    } // Partial application for functional programming


    filesize.partial = function (opt) {
      return function (arg) {
        return filesize(arg, opt);
      };
    }; // CommonJS, AMD, script tag


    {
      module.exports = filesize;
    }
  })();
});

var _CONSTANT_TIMEBASES;

var PAL = 'PAL';
var NTSC = 'NTSC';
var NTSC30 = 'NTSC30';
var CONSTANT_TIMEBASES = (_CONSTANT_TIMEBASES = {}, _defineProperty(_CONSTANT_TIMEBASES, PAL, {
  denominator: 25,
  numerator: 1
}), _defineProperty(_CONSTANT_TIMEBASES, NTSC, {
  denominator: 30000,
  numerator: 1001
}), _defineProperty(_CONSTANT_TIMEBASES, NTSC30, {
  denominator: 30,
  numerator: 1
}), _defineProperty(_CONSTANT_TIMEBASES, 29.97, {
  denominator: 30000,
  numerator: 1001
}), _defineProperty(_CONSTANT_TIMEBASES, 59.94, {
  denominator: 60000,
  numerator: 1001
}), _CONSTANT_TIMEBASES);
var FRAME_SEPARATORS = {
  ':': {
    dropFrame: false,
    field: 2
  },
  ';': {
    dropFrame: true,
    field: 2
  },
  '.': {
    dropFrame: false,
    field: 1
  },
  ',': {
    dropFrame: true,
    field: 1
  }
};

var splitSmpte = function splitSmpte(smpteText) {
  var hasDropFrameSeparator = smpteText.match(/[^0-9:\-_]/);
  var hhmmssff;
  var frameOptions = {};

  if (hasDropFrameSeparator) {
    var _hasDropFrameSeparato = _slicedToArray(hasDropFrameSeparator, 1),
        frameSeparator = _hasDropFrameSeparato[0];

    var _smpteText$split = smpteText.split(frameSeparator),
        _smpteText$split2 = _slicedToArray(_smpteText$split, 2),
        hhmmss = _smpteText$split2[0],
        splitFrames = _smpteText$split2[1];

    hhmmssff = [].concat(_toConsumableArray(hhmmss.split(':')), [splitFrames]);
    frameOptions = FRAME_SEPARATORS[frameSeparator] || {};
  } else {
    hhmmssff = smpteText.split(':');
  }

  hhmmssff = hhmmssff.map(Number);

  if (hhmmssff.length > 4 || hhmmssff.some(function (n) {
    return Number.isNaN(n);
  })) {
    throw new Error('Invalid SMPTE timecode');
  }

  return [hhmmssff, frameOptions];
};

var getDropFrames = function getDropFrames(roundedFrameRate) {
  return roundedFrameRate === 60 ? 4 : 2;
};

var getRoundedFrameRate = function getRoundedFrameRate(timeBase) {
  return Math.round(timeBase.denominator / timeBase.numerator);
};

var countSamples = function countSamples(hh, mm, ss, ff, _ref) {
  var dropFrame = _ref.dropFrame,
      roundedFrameRate = _ref.roundedFrameRate;

  if (!dropFrame) {
    return hh * 3600 * roundedFrameRate + mm * 60 * roundedFrameRate + ss * roundedFrameRate + ff;
  }

  if (![30, 60].includes(roundedFrameRate)) {
    throw new Error('Cannot use dropframe with non NTSC timebase');
  }

  var dropFrames = getDropFrames(roundedFrameRate);
  var shouldDropMinute = mm % 10 !== 0;
  var shouldDropSecond = shouldDropMinute && ss === 0;
  var hourFrames = hh * (3600 * roundedFrameRate - 54 * dropFrames);
  var minuteFrames = mm * 60 * roundedFrameRate - (mm - Math.ceil(mm / 10)) * dropFrames;
  var secondFrames = ss * roundedFrameRate - (shouldDropMinute && ss > 1 ? dropFrames : 0);

  if (shouldDropSecond && ff < dropFrames) {
    throw new Error('Invalid ff');
  }

  var frameFrames = shouldDropSecond ? ff - dropFrames : ff;
  return hourFrames + minuteFrames + secondFrames + frameFrames;
};

function countDroppedFrames(frames, roundedFrameRate) {
  var dropFrames = getDropFrames(roundedFrameRate);
  var oneMinuteUndroppedFrames = 60 * roundedFrameRate;
  var oneMinuteDroppedFrames = 60 * roundedFrameRate - dropFrames;
  var tenMinuteFrames = 10 * (oneMinuteUndroppedFrames - dropFrames) + dropFrames;
  var tenMinuteChunks = Math.floor(frames / tenMinuteFrames);
  var minuteRemainder = Math.max(0, frames % tenMinuteFrames - oneMinuteUndroppedFrames);
  var oneMinuteChunks = Math.floor(minuteRemainder / oneMinuteDroppedFrames);
  var frameRemainder = minuteRemainder % oneMinuteDroppedFrames;
  var frameChunks = frameRemainder > 0 ? dropFrames : 0;
  return tenMinuteChunks * 9 * dropFrames + oneMinuteChunks * dropFrames + frameChunks;
}

var TimeBase = /*#__PURE__*/function () {
  function TimeBase() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$numerator = _ref2.numerator,
        numerator = _ref2$numerator === void 0 ? 1 : _ref2$numerator,
        _ref2$denominator = _ref2.denominator,
        denominator = _ref2$denominator === void 0 ? 1 : _ref2$denominator;

    _classCallCheck(this, TimeBase);

    this.numerator = Number(numerator);
    this.denominator = Number(denominator);
  }

  _createClass(TimeBase, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        denominator: this.denominator,
        numerator: this.numerator
      };
    }
  }, {
    key: "toConstant",
    value: function toConstant() {
      var _this = this;

      var constant;
      Object.entries(CONSTANT_TIMEBASES).find(function (thisTimeBase) {
        var _thisTimeBase = _slicedToArray(thisTimeBase, 2),
            thisTimeBaseText = _thisTimeBase[0],
            thisTimeBaseType = _thisTimeBase[1];

        var numerator = thisTimeBaseType.numerator,
            denominator = thisTimeBaseType.denominator;

        if (numerator === _this.numerator && denominator === _this.denominator) {
          constant = thisTimeBaseText;
          return true;
        }

        return false;
      });
      return constant;
    }
  }, {
    key: "toText",
    value: function toText() {
      var useConstant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useConstant) {
        var _timeBaseText = this.toConstant();

        if (_timeBaseText) return _timeBaseText;
      }

      if (this.numerator > 1) {
        var _timeBaseText2 = [this.denominator, this.numerator].join(':');

        return _timeBaseText2;
      }

      var timeBaseText = String(this.denominator);
      return timeBaseText;
    }
  }, {
    key: "toRate",
    value: function toRate() {
      var useConstant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (useConstant) {
        var _rate = this.toConstant();

        if (_rate) return _rate;
      }

      var rate = this.denominator / this.numerator;

      if (Number.isInteger(rate)) {
        return rate;
      }

      return round ? rate.toFixed(2) : rate;
    }
  }]);

  return TimeBase;
}();

var isDropFrameTimeBase = function isDropFrameTimeBase(_ref3) {
  var numerator = _ref3.numerator,
      denominator = _ref3.denominator;
  return numerator === 1001 && (denominator === 60000 || denominator === 30000);
};

var TimeCode = /*#__PURE__*/function () {
  function TimeCode() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$samples = _ref4.samples,
        samples = _ref4$samples === void 0 ? 0 : _ref4$samples,
        timeBase = _ref4.timeBase;

    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        dropFrame = _ref5.dropFrame,
        _ref5$field = _ref5.field,
        field = _ref5$field === void 0 ? 2 : _ref5$field;

    _classCallCheck(this, TimeCode);

    if (typeof samples === 'number') {
      this.samples = samples;
    } else if (typeof samples === 'string') {
      if (samples === '-INF') {
        this.samples = -Infinity;
      } else if (samples === '+INF') {
        this.samples = Infinity;
      } else {
        this.samples = Number(samples);
      }
    } else {
      throw new Error("samples is not number/string/-Inf/+Inf is: ".concat(samples));
    }

    this.timeBase = new TimeBase(timeBase);
    this.dropFrame = dropFrame === undefined ? isDropFrameTimeBase(this.timeBase) : dropFrame;
    this.field = field;
  }

  _createClass(TimeCode, [{
    key: "add",
    value: function add(val) {
      var _val$timeBase = val.timeBase,
          numerator = _val$timeBase.numerator,
          denominator = _val$timeBase.denominator;
      var conformedTimeCode = val;

      if (numerator !== this.timeBase.numerator || denominator !== this.timeBase.denominator) {
        conformedTimeCode = val.conformTimeBase(this.timeBase);
      }

      var _conformedTimeCode = conformedTimeCode,
          samples = _conformedTimeCode.samples;
      return new TimeCode({
        samples: this.samples + samples,
        timeBase: this.timeBase
      });
    }
  }, {
    key: "subtract",
    value: function subtract(val) {
      var _val$timeBase2 = val.timeBase,
          numerator = _val$timeBase2.numerator,
          denominator = _val$timeBase2.denominator;
      var conformedTimeCode = val;

      if (numerator !== this.timeBase.numerator || denominator !== this.timeBase.denominator) {
        conformedTimeCode = val.conformTimeBase(this.timeBase);
      }

      var _conformedTimeCode2 = conformedTimeCode,
          samples = _conformedTimeCode2.samples;
      return new TimeCode({
        samples: this.samples - samples,
        timeBase: this.timeBase
      });
    }
  }, {
    key: "conformTimeBase",
    value: function conformTimeBase(conformTo) {
      var timeBase = conformTo;

      if (conformTo instanceof TimeCode === false) {
        timeBase = new TimeBase(conformTo);
      }

      var samples = Math.round(this.samples / (this.timeBase.toRate(false, false) / timeBase.toRate(false, false)));
      var timeCode = {
        samples: samples,
        timeBase: timeBase
      };
      return new TimeCode(timeCode);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        samples: this.samples,
        timeBase: this.timeBase
      };
    }
  }, {
    key: "toText",
    value: function toText() {
      var timeCodeText = String(this.samples);
      var timeBaseText = this.timeBase.toText();

      if (timeBaseText !== '1') {
        timeCodeText = [this.samples, timeBaseText].join('@');
      }

      return timeCodeText;
    }
  }, {
    key: "toSeconds",
    value: function toSeconds() {
      var _this$timeBase = this.timeBase,
          numerator = _this$timeBase.numerator,
          denominator = _this$timeBase.denominator;
      return this.samples * (numerator / denominator);
    }
  }, {
    key: "toTime",
    value: function toTime() {
      var roundedFrameRate = getRoundedFrameRate(this.timeBase);
      var totalSamples = this.samples + (this.dropFrame ? countDroppedFrames(this.samples + 1, roundedFrameRate) : 0);
      var hours = Math.floor(totalSamples / (3600 * roundedFrameRate));
      var minutes = Math.floor(totalSamples / (60 * roundedFrameRate)) % 60;
      var seconds = Math.floor(totalSamples / roundedFrameRate) % 60;
      var frames = totalSamples % roundedFrameRate;
      var partialSeconds = frames / roundedFrameRate;
      return {
        hours: hours,
        minutes: minutes,
        seconds: seconds,
        frames: frames,
        partialSeconds: partialSeconds
      };
    }
  }, {
    key: "toDuration",
    value: function toDuration() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          format = _ref6.format;

      var _this$toTime = this.toTime(),
          hours = _this$toTime.hours,
          minutes = _this$toTime.minutes,
          seconds = _this$toTime.seconds;

      if (typeof format === 'string') {
        if (format.toLowerCase() === 'hhmmss') {
          return [hours.toFixed().padStart(2, '0'), minutes.toFixed().padStart(2, '0'), seconds.toFixed().padStart(2, '0')].join(':');
        }
      }

      if (hours) {
        return [hours.toFixed(), minutes.toFixed().padStart(2, '0'), seconds.toFixed().padStart(2, '0')].join(':');
      }

      if (minutes >= 10) {
        return [minutes.toFixed().padStart(2, '0'), seconds.toFixed().padStart(2, '0')].join(':');
      }

      return [minutes.toFixed(), seconds.toFixed().padStart(2, '0')].join(':');
    }
  }, {
    key: "toSmpte",
    value: function toSmpte() {
      var _this2 = this;

      if (this.samples === -Infinity) return '00:00:00:00';

      var _this$toTime2 = this.toTime(),
          hours = _this$toTime2.hours,
          minutes = _this$toTime2.minutes,
          seconds = _this$toTime2.seconds,
          frames = _this$toTime2.frames;

      var hhmmss = [hours.toFixed().padStart(2, '0'), minutes.toFixed().padStart(2, '0'), seconds.toFixed().padStart(2, '0')].join(':');

      var _Object$entries$find = Object.entries(FRAME_SEPARATORS).find(function (thisSeparator) {
        var _thisSeparator = _slicedToArray(thisSeparator, 2),
            _thisSeparator$ = _thisSeparator[1],
            dropFrame = _thisSeparator$.dropFrame,
            field = _thisSeparator$.field;

        return dropFrame === _this2.dropFrame && field === _this2.field;
      }),
          _Object$entries$find2 = _slicedToArray(_Object$entries$find, 1),
          _Object$entries$find3 = _Object$entries$find2[0],
          frameSeparator = _Object$entries$find3 === void 0 ? ':' : _Object$entries$find3;

      return [hhmmss, frames.toFixed().padStart(2, '0')].join(frameSeparator);
    }
  }, {
    key: "toFraction",
    value: function toFraction() {
      return "".concat(this.samples, "@").concat(this.timeBase.denominator, ":").concat(this.timeBase.numerator);
    }
  }]);

  return TimeCode;
}();

var formatTimeBaseType = function formatTimeBaseType(timeBase) {
  return new TimeBase(timeBase);
};

var formatTimeBaseText = function formatTimeBaseText(timeBaseText) {
  if (timeBaseText === undefined) {
    return formatTimeBaseType();
  }

  if (typeof timeBaseText === 'number') {
    return formatTimeBaseType({
      denominator: timeBaseText
    });
  }

  if (timeBaseText.includes(':')) {
    var _timeBaseText$split = timeBaseText.split(':'),
        _timeBaseText$split2 = _slicedToArray(_timeBaseText$split, 2),
        _denominator = _timeBaseText$split2[0],
        numerator = _timeBaseText$split2[1];

    return formatTimeBaseType({
      denominator: _denominator,
      numerator: numerator
    });
  }

  if (Object.keys(CONSTANT_TIMEBASES).includes(timeBaseText)) {
    return formatTimeBaseType(CONSTANT_TIMEBASES[timeBaseText]);
  }

  var denominator = Number(timeBaseText);

  if (Number.isNaN(denominator)) {
    throw new Error("timeBaseText must be a number or ".concat(Object.keys(CONSTANT_TIMEBASES).join(','), " - is ").concat(timeBaseText));
  }

  return formatTimeBaseType({
    denominator: denominator
  });
};

var formatTimeBase = function formatTimeBase(timeBase) {
  if (_typeof(timeBase) === 'object') {
    return formatTimeBaseType(timeBase);
  }

  return formatTimeBaseText(timeBase);
};

var formatTimeCodeType = function formatTimeCodeType(timeCode, options) {
  return new TimeCode(timeCode, options);
};

var formatTimeCodeText = function formatTimeCodeText(timeCodeText, options) {
  if (timeCodeText === undefined) {
    var _timeCode = {
      samples: 0
    };
    return formatTimeCodeType(_timeCode, options);
  }

  if (typeof timeCodeText === 'number') {
    var _timeCode2 = {
      samples: timeCodeText
    };
    return formatTimeCodeType(_timeCode2, options);
  }

  if (timeCodeText.includes('@')) {
    var _timeCodeText$split = timeCodeText.split('@'),
        _timeCodeText$split2 = _slicedToArray(_timeCodeText$split, 2),
        samplesString = _timeCodeText$split2[0],
        timeBaseText = _timeCodeText$split2[1];

    var _samples = Number(samplesString);

    var timeBase = formatTimeBaseText(timeBaseText);
    var _timeCode3 = {
      samples: _samples,
      timeBase: timeBase
    };
    return formatTimeCodeType(_timeCode3, options);
  }

  if (timeCodeText === '-INF') {
    var _samples2 = -Infinity;

    var _timeCode4 = {
      samples: _samples2
    };
    return formatTimeCodeType(_timeCode4, options);
  }

  if (timeCodeText === '+INF') {
    var _samples3 = Infinity;
    var _timeCode5 = {
      samples: _samples3
    };
    return formatTimeCodeType(_timeCode5, options);
  }

  var samples = Number(timeCodeText);

  if (Number.isNaN(samples)) {
    throw new Error("timeBaseText must be a number or sample@timeBase - is ".concat(timeCodeText));
  }

  var timeCode = {
    samples: samples
  };
  return formatTimeCodeType(timeCode, options);
};

var formatSeconds = function formatSeconds(seconds) {
  var timeBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 ? arguments[2] : undefined;

  if (Number.isNaN(Number(seconds))) {
    throw new Error("seconds must be digits, is ".concat(seconds));
  }

  var _timeBase$denominator = timeBase.denominator,
      denominator = _timeBase$denominator === void 0 ? 1 : _timeBase$denominator,
      _timeBase$numerator = timeBase.numerator,
      numerator = _timeBase$numerator === void 0 ? 1 : _timeBase$numerator;
  var samples = seconds * (denominator / numerator);
  var timeCode = {
    samples: samples,
    timeBase: timeBase
  };
  return new TimeCode(timeCode, options);
};

var formatSecondsPrecise = function formatSecondsPrecise(seconds) {
  var timeBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 ? arguments[2] : undefined;

  if (Number.isNaN(Number(seconds))) {
    throw new Error("seconds must be digits, is ".concat(seconds));
  }

  var _timeBase$numerator2 = timeBase.numerator,
      numerator = _timeBase$numerator2 === void 0 ? 1 : _timeBase$numerator2;
  var _timeBase$denominator2 = timeBase.denominator,
      denominator = _timeBase$denominator2 === void 0 ? 1 : _timeBase$denominator2;

  if (!Number.isInteger(seconds)) {
    var decimalPlaces = String(seconds).split('.')[1].length;
    denominator *= Math.pow(10, decimalPlaces);
  }

  var samples = (seconds * (denominator / numerator)).toFixed();
  var timeCode = {
    samples: samples,
    timeBase: {
      denominator: denominator,
      numerator: numerator
    }
  };
  return new TimeCode(timeCode, options);
};

var formatSmpte = function formatSmpte(smpteText, timeBaseText) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (smpteText === undefined) {
    var _timeBase = formatTimeBase(timeBaseText);

    var _timeCode6 = {
      samples: 0,
      timeBase: _timeBase
    };
    return formatTimeCodeType(_timeCode6);
  }

  if (typeof smpteText !== 'string') {
    throw new Error("smpteText must be a string, is ".concat(smpteText));
  }

  var _splitSmpte = splitSmpte(smpteText),
      _splitSmpte2 = _slicedToArray(_splitSmpte, 2),
      _splitSmpte2$ = _slicedToArray(_splitSmpte2[0], 4),
      hh = _splitSmpte2$[0],
      mm = _splitSmpte2$[1],
      ss = _splitSmpte2$[2],
      _splitSmpte2$$ = _splitSmpte2$[3],
      ff = _splitSmpte2$$ === void 0 ? 0 : _splitSmpte2$$,
      frameOptions = _splitSmpte2[1];

  var _frameOptions$dropFra = frameOptions.dropFrame,
      dropFrame = _frameOptions$dropFra === void 0 ? false : _frameOptions$dropFra;
  var timeBase = formatTimeBase(timeBaseText);
  var roundedFrameRate = getRoundedFrameRate(timeBase);

  if (mm >= 60 || mm < 0 || ss >= 60 || ss < 0 || ff >= roundedFrameRate || ff < 0) {
    throw new Error('Invalid mm, ss or ff');
  }

  var samples = countSamples(hh, mm, ss, ff, {
    dropFrame: dropFrame,
    roundedFrameRate: roundedFrameRate
  });
  var timeCode = {
    samples: samples,
    timeBase: timeBase
  };
  return formatTimeCodeType(timeCode, _objectSpread2(_objectSpread2({}, frameOptions), options));
};

var parseKeyValuePairType = function parseKeyValuePairType() {
  var keyValuePairType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var keyValuePairTypeReducer = function keyValuePairTypeReducer(a, _ref) {
    var key = _ref.key,
        value = _ref.value;
    return _objectSpread2(_objectSpread2({}, a), {}, _defineProperty({}, key, value));
  };

  return keyValuePairType.reduce(keyValuePairTypeReducer, {});
};

var sampleRateSymbols = {
  kB: 'kHz',
  B: 'Hz',
  mB: 'mHz'
};
var bitRateSymbols = {
  kB: 'kbps',
  B: 'bps',
  MB: 'mbps'
};

var gcd = function gcd(a, b) {
  return b ? gcd(b, a % b) : a;
};

var parseAspectRatio = function parseAspectRatio(_ref) {
  var width = _ref.width,
      height = _ref.height;
  var denominator = gcd(width, height);
  var widthRatio = width / denominator;
  var heightRatio = height / denominator;

  if (widthRatio > 21) {
    heightRatio = 1;
    widthRatio = (width / height).toFixed(2);
  }

  return [widthRatio, heightRatio].join(':');
};

var parseBaseMediaInfoType = function parseBaseMediaInfoType() {
  var baseMediaInfoType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var keyValuePairType = baseMediaInfoType.property,
      props = _objectWithoutProperties(baseMediaInfoType, ["property"]);

  var parsedKeyValuePairType = parseKeyValuePairType(keyValuePairType);
  return _objectSpread2(_objectSpread2({}, parsedKeyValuePairType), props);
};

var parseFileType = function parseFileType(fileType) {
  var _fileType$uri = fileType.uri,
      uriList = _fileType$uri === void 0 ? [] : _fileType$uri,
      fileSizeBytes = fileType.size,
      hash = fileType.hash,
      path = fileType.path,
      fileId = fileType.id;

  var _uriList = _slicedToArray(uriList, 1),
      uri = _uriList[0];

  var fileSize = fileSizeBytes !== undefined ? filesize(fileSizeBytes) : '';
  var fileName = path ? path.split('/').pop() : undefined;
  return {
    uri: uri,
    hash: hash,
    fileSize: fileSize,
    fileSizeBytes: fileSizeBytes,
    path: path,
    fileName: fileName,
    fileId: fileId
  };
};

var parseContainerComponent = function parseContainerComponent(containerComponent) {
  var _containerComponent$m = containerComponent.mediaInfo,
      mediaInfo = _containerComponent$m === void 0 ? {} : _containerComponent$m,
      _containerComponent$m2 = containerComponent.metadata,
      metadata = _containerComponent$m2 === void 0 ? [] : _containerComponent$m2,
      fileList = containerComponent.file,
      durationTimeCode = containerComponent.duration,
      startTimestamp = containerComponent.startTimestamp,
      startTimecode = containerComponent.startTimecode,
      timeCodeTimeBase = containerComponent.timeCodeTimeBase;
  var containerMetadata = parseKeyValuePairType(metadata);
  var containerMediaInfo = parseBaseMediaInfoType(mediaInfo);
  var containerFormat = containerMediaInfo.Format;
  var videoFormat = containerMediaInfo.Video_Format_List,
      audioFormat = containerMediaInfo.Audio_Format_List,
      textFormat = containerMediaInfo.Text_Format_List;

  if (containerFormat === undefined) {
    var format = containerComponent.format;
    containerFormat = format;

    if (format && format.includes(',')) {
      var formatList = format.split(',');

      var _formatList = _slicedToArray(formatList, 1);

      containerFormat = _formatList[0];
    }
  }

  var parsedContainerComponent = {
    containerFormat: containerFormat,
    videoFormat: videoFormat,
    audioFormat: audioFormat,
    textFormat: textFormat,
    containerMetadata: containerMetadata,
    containerMediaInfo: containerMediaInfo
  };

  if (containerMetadata.componentOriginalFilename) {
    parsedContainerComponent.originalFilename = containerMetadata.componentOriginalFilename;
  }

  if (durationTimeCode !== undefined && durationTimeCode.samples !== 0) {
    parsedContainerComponent.durationTimeCode = formatTimeCodeType(durationTimeCode);
    parsedContainerComponent.duration = parsedContainerComponent.durationTimeCode.toDuration();
  }

  if (startTimestamp) {
    parsedContainerComponent.startTimestamp = formatTimeCodeType(startTimestamp);
  }

  if (startTimecode !== undefined && timeCodeTimeBase) {
    parsedContainerComponent.startTimecode = formatTimeCodeType({
      samples: startTimecode,
      timeBase: timeCodeTimeBase
    });
  }

  if (fileList) {
    var _fileList = _slicedToArray(fileList, 1),
        fileType = _fileList[0];

    var parsedFileType = parseFileType(fileType);
    parsedContainerComponent = _objectSpread2(_objectSpread2({}, parsedContainerComponent), parsedFileType);
  }

  return parsedContainerComponent;
};

var parseVideoComponent = function parseVideoComponent(videoComponent) {
  var videoCodec = videoComponent.codec,
      bitrate = videoComponent.bitrate,
      fieldOrder = videoComponent.fieldOrder,
      _videoComponent$resol = videoComponent.resolution,
      resolution = _videoComponent$resol === void 0 ? {} : _videoComponent$resol,
      _videoComponent$media = videoComponent.mediaInfo,
      mediaInfo = _videoComponent$media === void 0 ? {} : _videoComponent$media,
      _videoComponent$metad = videoComponent.metadata,
      metadata = _videoComponent$metad === void 0 ? [] : _videoComponent$metad;
  var videoMediaInfo = parseBaseMediaInfoType(mediaInfo);
  var videoMetadata = parseKeyValuePairType(metadata);
  var videoFormat = videoMediaInfo.Format,
      timeBaseText = videoMediaInfo['Frame rate'],
      colorSpace = videoMediaInfo['Color space'],
      colorPrimaries = videoMediaInfo['Color primaries'],
      chromaSubsampling = videoMediaInfo.Colorimetry;
  var timeBase;
  var averageFrameRate = videoComponent.averageFrameRate,
      realBaseFrameRate = videoComponent.realBaseFrameRate;

  if (realBaseFrameRate !== undefined) {
    timeBase = {
      numerator: realBaseFrameRate.denominator,
      denominator: realBaseFrameRate.numerator
    };
  } else if (timeBaseText !== undefined) {
    timeBase = formatTimeBaseText(timeBaseText);
  } else if (averageFrameRate !== undefined) {
    timeBase = {
      numerator: averageFrameRate.denominator,
      denominator: averageFrameRate.numerator
    };
  }

  var samples = videoMediaInfo['Frame count'];

  if (samples === undefined) {
    var numberOfPackets = videoComponent.numberOfPackets;
    if (numberOfPackets !== undefined) samples = numberOfPackets;
  }

  var timeCode;
  var frameRate;
  var smpte;

  if (samples && timeBase) {
    timeCode = formatTimeCodeType({
      samples: samples,
      timeBase: timeBase
    });
    frameRate = timeCode.timeBase.toRate(true);
    smpte = timeCode.toSmpte(true);
  }

  var height = resolution.height,
      width = resolution.width;
  var aspectRatio = parseAspectRatio(resolution);
  var dimension = "".concat(width, "x").concat(height);
  var videoBitrate = bitrate ? filesize(bitrate, {
    bits: true
  }) : undefined;
  return {
    videoFormat: videoFormat,
    dimension: dimension,
    frameRate: frameRate,
    height: height,
    width: width,
    timeBase: timeBase,
    timeCode: timeCode,
    videoCodec: videoCodec,
    smpte: smpte,
    videoBitrate: videoBitrate,
    fieldOrder: fieldOrder,
    colorSpace: colorSpace,
    chromaSubsampling: chromaSubsampling,
    aspectRatio: aspectRatio,
    colorPrimaries: colorPrimaries,
    videoMetadata: videoMetadata,
    videoMediaInfo: videoMediaInfo
  };
};

var parseAudioComponent = function parseAudioComponent(audioComponent) {
  var _audioComponent$timeB = audioComponent.timeBase,
      timeBase = _audioComponent$timeB === void 0 ? {} : _audioComponent$timeB,
      audioChannels = audioComponent.channelCount,
      audioCodec = audioComponent.codec,
      _audioComponent$media = audioComponent.mediaInfo,
      mediaInfo = _audioComponent$media === void 0 ? {} : _audioComponent$media,
      bitrate = audioComponent.bitrate,
      _audioComponent$metad = audioComponent.metadata,
      metadata = _audioComponent$metad === void 0 ? [] : _audioComponent$metad;
  var audioMediaInfo = parseBaseMediaInfoType(mediaInfo);
  var audioMetadata = parseKeyValuePairType(metadata);
  var audioFormat = audioMediaInfo.Format,
      audioBitDepth = audioMediaInfo.Resolution,
      audioBitRateMode = audioMediaInfo.Bit_rate_mode;
  var audioSamplerateSamples = timeBase.denominator ? timeBase.denominator / timeBase.numerator : undefined;
  var audioSamplerate = audioSamplerateSamples ? filesize(audioSamplerateSamples, {
    base: 10,
    round: 1,
    symbols: sampleRateSymbols
  }) : undefined;
  var audioBitrate = bitrate ? filesize(bitrate, {
    base: 10,
    round: 2,
    symbols: bitRateSymbols
  }) : undefined;
  return {
    audioFormat: audioFormat,
    audioCodec: audioCodec,
    audioSamplerate: audioSamplerate,
    audioSamplerateSamples: audioSamplerateSamples,
    audioBitDepth: audioBitDepth,
    audioBitrate: audioBitrate,
    audioBitRateMode: audioBitRateMode,
    audioChannels: audioChannels,
    audioMediaInfo: audioMediaInfo,
    audioMetadata: audioMetadata
  };
};

var parseBinaryComponent = function parseBinaryComponent(binaryComponent) {
  var fileList = binaryComponent.file,
      _binaryComponent$medi = binaryComponent.mediaInfo,
      mediaInfo = _binaryComponent$medi === void 0 ? {} : _binaryComponent$medi,
      _binaryComponent$meta = binaryComponent.metadata,
      metadata = _binaryComponent$meta === void 0 ? [] : _binaryComponent$meta;
  var binaryMetadata = parseKeyValuePairType(metadata);
  var binaryMediaInfo = parseBaseMediaInfoType(mediaInfo);
  var parsedBinaryComponent = {
    binaryMetadata: binaryMetadata,
    binaryMediaInfo: binaryMediaInfo
  };

  if (fileList) {
    var _fileList2 = _slicedToArray(fileList, 1),
        fileType = _fileList2[0];

    var parsedFileType = parseFileType(fileType);
    parsedBinaryComponent = _objectSpread2(_objectSpread2({}, parsedBinaryComponent), parsedFileType);
  }

  return parsedBinaryComponent;
};

var parseShapeType = function parseShapeType() {
  var shapeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var parsedShape = {};
  var containerComponent = shapeType.containerComponent,
      videoComponentList = shapeType.videoComponent,
      audioComponentList = shapeType.audioComponent,
      binaryComponentList = shapeType.binaryComponent,
      _shapeType$mimeType = shapeType.mimeType,
      mimeTypeList = _shapeType$mimeType === void 0 ? [] : _shapeType$mimeType,
      _shapeType$tag = shapeType.tag,
      tagList = _shapeType$tag === void 0 ? [] : _shapeType$tag;

  var _tagList = _slicedToArray(tagList, 1);

  parsedShape.tag = _tagList[0];

  var _mimeTypeList = _slicedToArray(mimeTypeList, 1);

  parsedShape.mimeType = _mimeTypeList[0];

  if (containerComponent) {
    var parsedContainerComponent = parseContainerComponent(containerComponent);
    parsedShape = _objectSpread2(_objectSpread2({}, parsedShape), parsedContainerComponent);
  }

  if (videoComponentList) {
    var _videoComponentList = _slicedToArray(videoComponentList, 1),
        videoComponent = _videoComponentList[0];

    var parsedVideoComponent = parseVideoComponent(videoComponent);
    parsedShape = _objectSpread2(_objectSpread2({}, parsedShape), parsedVideoComponent);
  }

  if (audioComponentList) {
    var _audioComponentList = _slicedToArray(audioComponentList, 1),
        audioComponent = _audioComponentList[0];

    var parsedAudioComponent = parseAudioComponent(audioComponent);
    parsedShape = _objectSpread2(_objectSpread2({}, parsedShape), parsedAudioComponent);
  }

  if (binaryComponentList) {
    var _binaryComponentList = _slicedToArray(binaryComponentList, 1),
        binaryComponent = _binaryComponentList[0];

    var parsedBinaryComponent = parseBinaryComponent(binaryComponent);
    parsedShape = _objectSpread2(_objectSpread2({}, parsedShape), parsedBinaryComponent);
  }

  return parsedShape;
};

var parseMediaConvertPreset = function parseMediaConvertPreset(transcodePresetType) {
  var output = {};
  var description = transcodePresetType.description,
      _transcodePresetType$ = transcodePresetType.mediaconvert;
  _transcodePresetType$ = _transcodePresetType$ === void 0 ? {} : _transcodePresetType$;
  var _transcodePresetType$2 = _transcodePresetType$.outputSetting,
      outputSetting = _transcodePresetType$2 === void 0 ? [] : _transcodePresetType$2;
  output.description = description;
  if (outputSetting.length === 0) return output;
  var mc = JSON.parse(outputSetting[0]);
  var _mc$Settings = mc.Settings;
  _mc$Settings = _mc$Settings === void 0 ? {} : _mc$Settings;
  var ContainerSettings = _mc$Settings.ContainerSettings,
      VideoDescription = _mc$Settings.VideoDescription,
      AudioDescriptions = _mc$Settings.AudioDescriptions;
  output.containerFormat = ContainerSettings.Container;

  if (ContainerSettings) {
    output.containerFormat = ContainerSettings.Container;
  }

  if (VideoDescription) {
    var _VideoDescription$Cod = VideoDescription.CodecSettings,
        CodecSettings = _VideoDescription$Cod === void 0 ? {} : _VideoDescription$Cod;

    var Codec = CodecSettings.Codec,
        otherSettings = _objectWithoutProperties(CodecSettings, ["Codec"]);

    output.videoFormat = Codec;
    var height = VideoDescription.Height,
        width = VideoDescription.Width;
    output.height = height;
    output.width = width;

    if (height && width) {
      output.dimension = "".concat(width, "x").concat(height);
      output.aspectRatio = parseAspectRatio({
        height: height,
        width: width
      });
    }

    var _Object$values = Object.values(otherSettings),
        _Object$values2 = _slicedToArray(_Object$values, 1),
        codecSpecs = _Object$values2[0];

    if (codecSpecs) {
      output.fieldOrder = codecSpecs.InterlaceMode;
      if (output.fieldOrder && output.fieldOrder.includes('TOP')) output.fieldOrder = 'interlaced';
      output.videoBitrate = codecSpecs.Bitrate;
      var numerator = codecSpecs.FramerateDenominator; // other way round to vs \_()_/

      var denominator = codecSpecs.FramerateNumerator;
      var timeBase = formatTimeBaseType({
        denominator: denominator,
        numerator: numerator
      });
      output.timeBase = timeBase;
      output.frameRate = timeBase.toRate(true);
    }
  }

  if (AudioDescriptions && AudioDescriptions.length > 0) {
    var _AudioDescriptions$0$ = AudioDescriptions[0].CodecSettings,
        _CodecSettings = _AudioDescriptions$0$ === void 0 ? {} : _AudioDescriptions$0$;

    var _Codec = _CodecSettings.Codec,
        _otherSettings = _objectWithoutProperties(_CodecSettings, ["Codec"]);

    output.audioFormat = _Codec;

    var _Object$values3 = Object.values(_otherSettings),
        _Object$values4 = _slicedToArray(_Object$values3, 1),
        _codecSpecs = _Object$values4[0];

    if (_codecSpecs) {
      output.audioSamplerate = _codecSpecs.SampleRate;
      output.audioBitrate = _codecSpecs.Bitrate;
      output.audioBitRateMode = _codecSpecs.RateControlMode;
    }
  }

  return output;
};

var parseTranscodePreset = function parseTranscodePreset(transcodePresetType) {
  var output = {};
  var description = transcodePresetType.description,
      format = transcodePresetType.format,
      audio = transcodePresetType.audio,
      video = transcodePresetType.video,
      mediaconvert = transcodePresetType.mediaconvert;
  if (mediaconvert) return parseMediaConvertPreset(transcodePresetType);
  output.description = description;
  output.containerFormat = format;

  if (video) {
    output.videoFormat = video.codec;
    output.videoBitrate = video.bitrate;

    if (video.framerate) {
      var timeBase = formatTimeBaseType(video.framerate);
      output.timeBase = timeBase;
      output.frameRate = timeBase.toRate(true);
    }

    if (video.scaling) {
      var _video$scaling = video.scaling,
          height = _video$scaling.height,
          width = _video$scaling.width;
      output.height = height;
      output.width = width;

      if (height && width) {
        output.dimension = "".concat(width, "x").concat(height);
        output.aspectRatio = parseAspectRatio({
          height: height,
          width: width
        });
      }
    }
  }

  if (audio) {
    var audioFormat = audio.codec,
        channel = audio.channel;
    output.audioFormat = audioFormat;
    if (channel) output.audioChannels = channel.length;
  }

  return output;
};

var parseFacetType = function parseFacetType() {
  var facetType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var output = {};

  var facetFieldReducer = function facetFieldReducer(a, _ref) {
    var fieldValue = _ref.fieldValue,
        value = _ref.value;
    return _objectSpread2(_objectSpread2({}, a), {}, _defineProperty({}, fieldValue, value));
  };

  facetType.forEach(function (_ref2) {
    var name = _ref2.name,
        field = _ref2.field,
        count = _ref2.count;
    output[name || field] = count.reduce(facetFieldReducer, {});
  });
  return output;
}; // eslint-disable-next-line import/prefer-default-export

/* Note that VS may calculate +/- unit in another way */
var parseNowDate = function parseNowDate() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NOW';

  if (value.startsWith('NOW')) {
    if (value === 'NOW') return new Date();
    var sign = value[3];
    var number = Number(value.match(/(\d+)/)[0]);
    var unit = value.match(/(\d.*)/)[0].replace(/\d/g, '');
    var nowDiff = new Date(); // eslint-disable-next-line default-case

    switch (unit) {
      case 'HOUR':
      case 'HOURS':
        if (sign === '+') nowDiff.setHours(nowDiff.getHours() + number);
        if (sign === '-') nowDiff.setHours(nowDiff.getHours() - number);
        break;

      case 'DAY':
      case 'DAYS':
        if (sign === '+') nowDiff.setDate(nowDiff.getDate() + number);
        if (sign === '-') nowDiff.setDate(nowDiff.getDate() - number);
        break;

      case 'MONTH':
      case 'MONTHS':
        if (sign === '+') nowDiff.setMonth(nowDiff.getMonth() + number);
        if (sign === '-') nowDiff.setMonth(nowDiff.getMonth() - number);
        break;

      case 'YEAR':
      case 'YEARS':
        if (sign === '+') nowDiff.setFullYear(nowDiff.getFullYear() + number);
        if (sign === '-') nowDiff.setFullYear(nowDiff.getFullYear() - number);
        break;
    }

    return nowDiff;
  }

  return new Date(value);
};

var createFacetType = function createFacetType() {
  var fieldList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return fieldList.map(function (field) {
    return {
      field: field,
      name: field,
      count: options.count || true,
      exclude: fieldList
    };
  });
}; // eslint-disable-next-line import/prefer-default-export

/* eslint-disable import/prefer-default-export */
var parseValueList$1 = function parseValueList(value) {
  if (value === undefined) return [];
  if (value === null) return [{
    value: ''
  }];

  if (Array.isArray(value)) {
    return value.map(function (valueOrObject) {
      if (_typeof(valueOrObject) === 'object') {
        return _objectSpread2({
          value: valueOrObject.value || ''
        }, valueOrObject);
      }

      return {
        value: valueOrObject
      };
    });
  }

  if (value.value) return [value];
  return [{
    value: value
  }];
};

var parseValue = function parseValue() {
  var fieldValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (fieldValue && (fieldValue.value || fieldValue.name)) {
    var valueList = fieldValue.value,
        uuid = fieldValue.uuid;
    var value = parseValueList$1(valueList);
    return {
      value: value,
      uuid: uuid
    };
  }

  return {
    value: parseValueList$1(fieldValue)
  };
};

var parseField$1 = function parseField() {
  var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var name = field.name,
      value = field.value;
  var parsedValue = parseValue(value);
  return _objectSpread2({
    name: name
  }, parsedValue);
};

var shouldBeField = function shouldBeField(_ref) {
  var name = _ref.name,
      value = _ref.value;
  return ['string', 'boolean', 'number'].includes(_typeof(value)) || name !== 'group' && Array.isArray(value) || value === null;
};

var parseGroup$1 = function parseGroup() {
  var thisGroup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var groupName = thisGroup.name,
      _thisGroup$value = thisGroup.value,
      groupsOrFields = _thisGroup$value === void 0 ? {} : _thisGroup$value; // eslint-disable-next-line no-use-before-define

  var _parseGroupsOrFields = parseGroupsOrFields(groupsOrFields),
      field = _parseGroupsOrFields.field,
      group = _parseGroupsOrFields.group;

  return {
    name: groupName,
    group: group,
    field: field
  };
};

var parseGroupsOrFields = function parseGroupsOrFields(groupsOrFields) {
  var group = [];
  var field = [];
  Object.entries(groupsOrFields).forEach(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        name = _ref3[0],
        value = _ref3[1];

    if (shouldBeField({
      name: name,
      value: value
    })) {
      field.push(parseField$1({
        name: name,
        value: value
      }));
    } else if (Array.isArray(value)) {
      value.forEach(function (_ref4) {
        var groupName = _ref4.groupName,
            groupValue = _objectWithoutProperties(_ref4, ["groupName"]);

        // eslint-disable-next-line no-use-before-define
        group.push(parseGroup$1({
          name: groupName,
          value: groupValue
        }));
      });
    } else {
      // eslint-disable-next-line no-use-before-define
      group.push(parseGroup$1({
        name: name,
        value: value
      }));
    }
  });
  return {
    group: group,
    field: field
  };
};

var parseTimeSpan = function parseTimeSpan(timeSpan) {
  var _timeSpan$start = timeSpan.start,
      start = _timeSpan$start === void 0 ? '-INF' : _timeSpan$start,
      _timeSpan$end = timeSpan.end,
      end = _timeSpan$end === void 0 ? '+INF' : _timeSpan$end,
      groupsOrFields = _objectWithoutProperties(timeSpan, ["start", "end"]);

  var _parseGroupsOrFields2 = parseGroupsOrFields(groupsOrFields),
      group = _parseGroupsOrFields2.group,
      field = _parseGroupsOrFields2.field;

  return {
    start: start,
    end: end,
    field: field,
    group: group
  };
};

var createMetadataType = function createMetadataType() {
  var metadataType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var newMetadataType = {};

  if (Array.isArray(metadataType)) {
    newMetadataType.timespan = metadataType.map(function (thisTimeSpan) {
      return parseTimeSpan(thisTimeSpan);
    });
  } else {
    var genericTimespan = parseTimeSpan(metadataType);
    newMetadataType.timespan = [genericTimespan];
  }

  return newMetadataType;
};

function timeToCueTime(_ref) {
  var _ref$hours = _ref.hours,
      hours = _ref$hours === void 0 ? 0 : _ref$hours,
      _ref$minutes = _ref.minutes,
      minutes = _ref$minutes === void 0 ? 0 : _ref$minutes,
      _ref$seconds = _ref.seconds,
      seconds = _ref$seconds === void 0 ? 0 : _ref$seconds,
      _ref$partialSeconds = _ref.partialSeconds,
      partialSeconds = _ref$partialSeconds === void 0 ? 0 : _ref$partialSeconds;
  var hourStr = hours.toFixed().padStart(2, '0');
  var minStr = minutes.toFixed().padStart(2, '0');
  var secondsStr = seconds.toFixed().padStart(2, '0');
  var partialStr = (partialSeconds * 10).toFixed().padStart(3, '0');
  return "".concat(hourStr, ":").concat(minStr, ":").concat(secondsStr, ".").concat(partialStr);
}

function metadataTypeToWebVtt(_ref2) {
  var metadataType = _ref2.metadataType,
      _ref2$subtitleGroup = _ref2.subtitleGroup,
      subtitleGroup = _ref2$subtitleGroup === void 0 ? 'stl_subtitle' : _ref2$subtitleGroup,
      _ref2$subtitleField = _ref2.subtitleField,
      subtitleField = _ref2$subtitleField === void 0 ? 'stl_text' : _ref2$subtitleField;
  var parseOptions = {
    includeTimespanAttributes: true,
    flatTimespan: true,
    flatGroup: true,
    joinValue: ','
  };

  var _ref3 = metadataType || {},
      _ref3$timespan = _ref3.timespan,
      timespanList = _ref3$timespan === void 0 ? [] : _ref3$timespan;

  if (timespanList.length === 0) return '';
  var sortedTimespans = timespanList.sort(sortTimespanList);
  var parsedTimespans = sortedTimespans.map(function (timespanType) {
    return parseTimespan(timespanType, parseOptions);
  });
  var vttCues = parsedTimespans.map(function (thisTimespan) {
    var startText = thisTimespan.start,
        endText = thisTimespan.end,
        _thisTimespan$subtitl = thisTimespan[subtitleGroup];
    _thisTimespan$subtitl = _thisTimespan$subtitl === void 0 ? {} : _thisTimespan$subtitl;
    var text = _thisTimespan$subtitl[subtitleField];
    if (!text) return '';
    var startTime = formatTimeCodeText(startText).toTime();
    var start = timeToCueTime(startTime);
    var endTime = formatTimeCodeText(endText).toTime();
    var end = timeToCueTime(endTime);
    return "".concat(start, " --> ").concat(end, " line:0%\r").concat(text, "\r");
  });
  return "WEBVTT\n\n\n".concat(vttCues.join('\n'));
}

var IMAGE_MIME_TYPES = ['image/apng', 'image/bmp', 'image/gif', 'image/jpeg', 'image/x-icon', 'image/png', 'image/svg+xml'];
var VIDEO_MIME_TYPES = ['video/mp4'];
var AUDIO_MIME_TYPES = ['audio/mp4', 'audio/mpeg', 'audio/x-aac', 'audio/aac', 'audio/x-wav', 'audio/wav', 'audio/accp', 'audio/ogg', 'audio/webm', 'audio/x-flac'];
var DEFAULT_ALLOWED_MIME_TYPES = [].concat(VIDEO_MIME_TYPES, IMAGE_MIME_TYPES, AUDIO_MIME_TYPES);
var DEFAULT_ALLOWED_METHODS = ['http', 'https'];
var MP4_MIMETYPE = 'video/mp4';
var QUICKTIME_MIMETYPE = 'video/quicktime';
var M4V_MIMETYPE = 'video/x-m4v';
var MP4_CONTAINER = 'MPEG-4';
var MOV_CONTAINER = 'mov';
var H264_CODEC = 'h264'; // Sort by tags in the order of previewShapeOrder, secondary alphabetical.
// using reverse() so the first has highest index

var PREVIEW_SHAPE_ORDER = ['__mp4', '__mp3_160k', '__png', '__jpeg', '__gif', 'original'].reverse();

var defaultSortPriority = function defaultSortPriority(_ref, _ref2) {
  var firstEl = _ref.shape.tag;
  var secondEl = _ref2.shape.tag;

  if (PREVIEW_SHAPE_ORDER.includes(firstEl) || PREVIEW_SHAPE_ORDER.includes(secondEl)) {
    return PREVIEW_SHAPE_ORDER.indexOf(secondEl) - PREVIEW_SHAPE_ORDER.indexOf(firstEl);
  }

  return firstEl.toLowerCase().localeCompare(secondEl.toLowerCase());
};

var filterShapeSource = function filterShapeSource() {
  var itemType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$allowedMimeT = options.allowedMimeTypes,
      allowedMimeTypes = _options$allowedMimeT === void 0 ? DEFAULT_ALLOWED_MIME_TYPES : _options$allowedMimeT,
      _options$sortPriority = options.sortPriority,
      sortPriority = _options$sortPriority === void 0 ? defaultSortPriority : _options$sortPriority,
      _options$allowedMetho = options.allowedMethods,
      allowedMethods = _options$allowedMetho === void 0 ? DEFAULT_ALLOWED_METHODS : _options$allowedMetho,
      _options$sourceKey = options.sourceKey,
      sourceKey = _options$sourceKey === void 0 ? 'src' : _options$sourceKey,
      _options$mimeTypeKey = options.mimeTypeKey,
      mimeTypeKey = _options$mimeTypeKey === void 0 ? 'type' : _options$mimeTypeKey,
      _options$shapeKey = options.shapeKey,
      shapeKey = _options$shapeKey === void 0 ? 'shape' : _options$shapeKey;
  var _itemType$shape = itemType.shape,
      shapeList = _itemType$shape === void 0 ? [] : _itemType$shape;
  var parsedShapeList = shapeList.reduce(function (acc, shapeType) {
    var type;
    var src;
    var shape = parseShapeType(shapeType);
    var uri = shape.uri,
        mimeType = shape.mimeType,
        containerFormat = shape.containerFormat,
        videoCodec = shape.videoCodec;

    if (mimeType) {
      type = mimeType;
      if ((mimeType === QUICKTIME_MIMETYPE || mimeType === M4V_MIMETYPE) && (containerFormat === MP4_CONTAINER || containerFormat === MOV_CONTAINER) && videoCodec === H264_CODEC) type = MP4_MIMETYPE;
    }

    if (uri) {
      if (allowedMethods) {
        var _uri$split = uri.split('://'),
            _uri$split2 = _slicedToArray(_uri$split, 1),
            thisMethod = _uri$split2[0];

        if (allowedMethods.includes(thisMethod)) src = uri;
      } else {
        src = uri;
      }
    }

    if (src && allowedMimeTypes.includes(type)) {
      var _acc$push;

      acc.push((_acc$push = {}, _defineProperty(_acc$push, sourceKey, src), _defineProperty(_acc$push, mimeTypeKey, type), _defineProperty(_acc$push, shapeKey, shape), _acc$push));
    }

    return acc;
  }, []);
  if (typeof sortPriority === 'function') parsedShapeList.sort(defaultSortPriority);
  return parsedShapeList;
};

var IMAGE = 'IMAGE';
var AUDIO = 'AUDIO';
var VIDEO = 'VIDEO';
var DOCUMENT = 'DOCUMENT';

var getShapeMediaType = function getShapeMediaType() {
  var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var mimeType = shape.mimeType,
      videoCodec = shape.videoCodec,
      audioCodec = shape.audioCodec;
  if (!mimeType) return undefined;

  if (mimeType.startsWith('audio/')) {
    if (audioCodec !== undefined) return AUDIO;
  }

  if (mimeType.startsWith('video/')) {
    if (videoCodec !== undefined) return VIDEO;
    if (audioCodec !== undefined) return AUDIO;
  }

  if (mimeType.startsWith('image/')) return IMAGE;
  if (mimeType.endsWith('/pdf')) return DOCUMENT;
  if (mimeType.startsWith('text/')) return DOCUMENT;
  if (mimeType.endsWith('/msword')) return DOCUMENT;
  if (mimeType.endsWith('/json')) return DOCUMENT;
  if (mimeType.endsWith('/xml')) return DOCUMENT;
  return undefined;
};

var findNearestThumbnail = function findNearestThumbnail() {
  var itemType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var timeCodeText = arguments.length > 1 ? arguments[1] : undefined;
  var tcSeconds = formatTimeCodeText(timeCodeText).toSeconds();
  var _itemType$thumbnails = itemType.thumbnails,
      thumbnails = _itemType$thumbnails === void 0 ? {} : _itemType$thumbnails;
  var _thumbnails$uri = thumbnails.uri,
      srcList = _thumbnails$uri === void 0 ? [] : _thumbnails$uri;
  var srcTcSeconds = srcList.map(function (url) {
    var tc = new URL(url).pathname.split('/').pop();
    return formatTimeCodeText(tc).toSeconds();
  });
  var nearestSrcIndex = srcTcSeconds.reduce(function (nearestIndex, curr, currIndex) {
    return Math.abs(curr - tcSeconds) < Math.abs(srcTcSeconds[nearestIndex] - tcSeconds) ? currIndex : nearestIndex;
  }, 0);
  return srcList[nearestSrcIndex];
};

var ACCESSCONTROL_READ = '_accesscontrol_read';
var ACCESSCONTROL_WRITE = '_accesscontrol_write';
var ADMINISTRATOR = '_administrator';
var AUTO_PROJECTION_READ = '_auto_projection_read';
var AUTO_PROJECTION_WRITE = '_auto_projection_write';
var COLLECTION_NOTIFICATION_READ = '_collection_notification_read';
var COLLECTION_NOTIFICATION_WRITE = '_collection_notification_write';
var COLLECTION_READ = '_collection_read';
var COLLECTION_WRITE = '_collection_write';
var DELETION_LOCK_NOTIFICATION_READ = '_deletion_lock_notification_read';
var DELETION_LOCK_NOTIFICATION_WRITE = '_deletion_lock_notification_write';
var DELETION_LOCK_READ = '_deletion_lock_read';
var DELETION_LOCK_WRITE = '_deletion_lock_write';
var DOCUMENT_NOTIFICATION_READ = '_document_notification_read';
var DOCUMENT_NOTIFICATION_WRITE = '_document_notification_write';
var DOCUMENT_READ = '_document_read';
var DOCUMENT_WRITE = '_document_write';
var ERROR_READ = '_error_read';
var ERROR_WRITE = '_error_write';
var EXPORT = '_export';
var EXPORT_TEMPLATE_READ = '_export_template_read';
var EXPORT_TEMPLATE_WRITE = '_export_template_write';
var EXTERNAL_ID_READ = '_external_id_read';
var EXTERNAL_ID_WRITE = '_external_id_write';
var FILE_NOTIFICATION_READ = '_file_notification_read';
var FILE_NOTIFICATION_WRITE = '_file_notification_write';
var FILE_READ = '_file_read';
var FILE_WRITE = '_file_write';
var GROUP_READ = '_group_read';
var GROUP_WRITE = '_group_write';
var IMPORT_WRITE = '_import';
var ITEM_ID_READ = '_item_id_read';
var ITEM_ID_WRITE = '_item_id_write';
var ITEM_NOTIFICATION_READ = '_item_notification_read';
var ITEM_NOTIFICATION_WRITE = '_item_notification_write';
var ITEM_WRITE = '_item_write';
var ITEM_SEARCH = '_item_search';
var ITEM_SHAPE_READ = '_item_shape_read';
var ITEM_SHAPE_WRITE = '_item_shape_write';
var ITEM_TIMELINE_READ = '_item_timeline_read';
var ITEM_TIMELINE_WRITE = '_item_timeline_write';
var ITEM_URI = '_item_uri';
var JOB_NOTIFICATION_READ = '_job_notification_read';
var JOB_NOTIFICATION_WRITE = '_job_notification_write';
var JOB_READ = '_job_read';
var JOB_WRITE = '_job_write';
var LIBRARY_READ = '_library_read';
var LIBRARY_WRITE = '_library_write';
var LOCK_READ = '_lock_read';
var LOCK_WRITE = '_lock_write';
var LOG_READ = '_log_read';
var METADATA_DATASET_READ = '_metadata_dataset_read';
var METADATA_DATASET_WRITE = '_metadata_dataset_write';
var METADATA_FIELD_GROUP_READ = '_metadata_field_group_read';
var METADATA_FIELD_GROUP_WRITE = '_metadata_field_group_write';
var METADATA_FIELD_READ = '_metadata_field_read';
var METADATA_FIELD_WRITE = '_metadata_field_write';
var METADATA_GLOBAL_READ = '_metadata_global_read';
var METADATA_GLOBAL_WRITE = '_metadata_global_write';
var METADATA_LOCK_READ = '_metadata_lock_read';
var METADATA_LOCK_WRITE = '_metadata_lock_write';
var METADATA_READ = '_metadata_read';
var METADATA_SCHEMA_READ = '_metadata_schema_read';
var METADATA_SCHEMA_WRITE = '_metadata_schema_write';
var METADATA_WRITE = '_metadata_write';
var OTIF_ANALYZE = '_otif_analyze';
var OTIF_READ = '_otif_read';
var OTIF_WRITE = '_otif_write';
var PLACEHOLDER_NOTIFICATION_READ = '_placeholder_notification_read';
var PLACEHOLDER_NOTIFICATION_WRITE = '_placeholder_notification_write';
var PROJECTION_READ = '_projection_read';
var PROJECTION_WRITE = '_projection_write';
var QUOTA_NOTIFICATION_READ = '_quota_notification_read';
var QUOTA_NOTIFICATION_WRITE = '_quota_notification_write';
var QUOTA_READ = '_quota_read';
var QUOTA_WRITE = '_quota_write';
var RELATION_READ = '_relation_read';
var RELATION_WRITE = '_relation_write';
var RESOURCE_READ = '_resource_read';
var RESOURCE_WRITE = '_resource_write';
var RUN_AS = '_run_as';
var SEARCH = '_search';
var SEQUENCE_READ = '_sequence_read';
var SEQUENCE_WRITE = '_sequence_write';
var SHAPE_TAG_READ = '_shape_tag_read';
var SHAPE_TAG_WRITE = '_shape_tag_write';
var SITE_MANAGER = '_site_manager';
var SITE_RULE_READ = '_site_rule_read';
var SITE_RULE_WRITE = '_site_rule_write';
var STORAGE_GROUP_READ = '_storage_group_read';
var STORAGE_GROUP_WRITE = '_storage_group_write';
var STORAGE_NOTIFICATION_READ = '_storage_notification_read';
var STORAGE_NOTIFICATION_WRITE = '_storage_notification_write';
var STORAGE_READ = '_storage_read';
var STORAGE_RULE_READ = '_storage_rule_read';
var STORAGE_RULE_WRITE = '_storage_rule_write';
var STORAGE_WRITE = '_storage_write';
var SUPER_ACCESS_USER = '_super_access_user';
var TASKDEFINITION_READ = '_taskdefinition_read';
var TASKDEFINITION_WRITE = '_taskdefinition_write';
var THUMBNAIL_READ = '_thumbnail_read';
var THUMBNAIL_WRITE = '_thumbnail_write';
var TRANSCODER = '_transcoder';
var TRANSFER_READ = '_transfer_read';
var TRANSFER_WRITE = '_transfer_write';
var USER = '_user';
var VXA = '_vxa';
var VXA_READ = '_vxa_read';

var roles = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ACCESSCONTROL_READ: ACCESSCONTROL_READ,
  ACCESSCONTROL_WRITE: ACCESSCONTROL_WRITE,
  ADMINISTRATOR: ADMINISTRATOR,
  AUTO_PROJECTION_READ: AUTO_PROJECTION_READ,
  AUTO_PROJECTION_WRITE: AUTO_PROJECTION_WRITE,
  COLLECTION_NOTIFICATION_READ: COLLECTION_NOTIFICATION_READ,
  COLLECTION_NOTIFICATION_WRITE: COLLECTION_NOTIFICATION_WRITE,
  COLLECTION_READ: COLLECTION_READ,
  COLLECTION_WRITE: COLLECTION_WRITE,
  DELETION_LOCK_NOTIFICATION_READ: DELETION_LOCK_NOTIFICATION_READ,
  DELETION_LOCK_NOTIFICATION_WRITE: DELETION_LOCK_NOTIFICATION_WRITE,
  DELETION_LOCK_READ: DELETION_LOCK_READ,
  DELETION_LOCK_WRITE: DELETION_LOCK_WRITE,
  DOCUMENT_NOTIFICATION_READ: DOCUMENT_NOTIFICATION_READ,
  DOCUMENT_NOTIFICATION_WRITE: DOCUMENT_NOTIFICATION_WRITE,
  DOCUMENT_READ: DOCUMENT_READ,
  DOCUMENT_WRITE: DOCUMENT_WRITE,
  ERROR_READ: ERROR_READ,
  ERROR_WRITE: ERROR_WRITE,
  EXPORT: EXPORT,
  EXPORT_TEMPLATE_READ: EXPORT_TEMPLATE_READ,
  EXPORT_TEMPLATE_WRITE: EXPORT_TEMPLATE_WRITE,
  EXTERNAL_ID_READ: EXTERNAL_ID_READ,
  EXTERNAL_ID_WRITE: EXTERNAL_ID_WRITE,
  FILE_NOTIFICATION_READ: FILE_NOTIFICATION_READ,
  FILE_NOTIFICATION_WRITE: FILE_NOTIFICATION_WRITE,
  FILE_READ: FILE_READ,
  FILE_WRITE: FILE_WRITE,
  GROUP_READ: GROUP_READ,
  GROUP_WRITE: GROUP_WRITE,
  IMPORT_WRITE: IMPORT_WRITE,
  ITEM_ID_READ: ITEM_ID_READ,
  ITEM_ID_WRITE: ITEM_ID_WRITE,
  ITEM_NOTIFICATION_READ: ITEM_NOTIFICATION_READ,
  ITEM_NOTIFICATION_WRITE: ITEM_NOTIFICATION_WRITE,
  ITEM_WRITE: ITEM_WRITE,
  ITEM_SEARCH: ITEM_SEARCH,
  ITEM_SHAPE_READ: ITEM_SHAPE_READ,
  ITEM_SHAPE_WRITE: ITEM_SHAPE_WRITE,
  ITEM_TIMELINE_READ: ITEM_TIMELINE_READ,
  ITEM_TIMELINE_WRITE: ITEM_TIMELINE_WRITE,
  ITEM_URI: ITEM_URI,
  JOB_NOTIFICATION_READ: JOB_NOTIFICATION_READ,
  JOB_NOTIFICATION_WRITE: JOB_NOTIFICATION_WRITE,
  JOB_READ: JOB_READ,
  JOB_WRITE: JOB_WRITE,
  LIBRARY_READ: LIBRARY_READ,
  LIBRARY_WRITE: LIBRARY_WRITE,
  LOCK_READ: LOCK_READ,
  LOCK_WRITE: LOCK_WRITE,
  LOG_READ: LOG_READ,
  METADATA_DATASET_READ: METADATA_DATASET_READ,
  METADATA_DATASET_WRITE: METADATA_DATASET_WRITE,
  METADATA_FIELD_GROUP_READ: METADATA_FIELD_GROUP_READ,
  METADATA_FIELD_GROUP_WRITE: METADATA_FIELD_GROUP_WRITE,
  METADATA_FIELD_READ: METADATA_FIELD_READ,
  METADATA_FIELD_WRITE: METADATA_FIELD_WRITE,
  METADATA_GLOBAL_READ: METADATA_GLOBAL_READ,
  METADATA_GLOBAL_WRITE: METADATA_GLOBAL_WRITE,
  METADATA_LOCK_READ: METADATA_LOCK_READ,
  METADATA_LOCK_WRITE: METADATA_LOCK_WRITE,
  METADATA_READ: METADATA_READ,
  METADATA_SCHEMA_READ: METADATA_SCHEMA_READ,
  METADATA_SCHEMA_WRITE: METADATA_SCHEMA_WRITE,
  METADATA_WRITE: METADATA_WRITE,
  OTIF_ANALYZE: OTIF_ANALYZE,
  OTIF_READ: OTIF_READ,
  OTIF_WRITE: OTIF_WRITE,
  PLACEHOLDER_NOTIFICATION_READ: PLACEHOLDER_NOTIFICATION_READ,
  PLACEHOLDER_NOTIFICATION_WRITE: PLACEHOLDER_NOTIFICATION_WRITE,
  PROJECTION_READ: PROJECTION_READ,
  PROJECTION_WRITE: PROJECTION_WRITE,
  QUOTA_NOTIFICATION_READ: QUOTA_NOTIFICATION_READ,
  QUOTA_NOTIFICATION_WRITE: QUOTA_NOTIFICATION_WRITE,
  QUOTA_READ: QUOTA_READ,
  QUOTA_WRITE: QUOTA_WRITE,
  RELATION_READ: RELATION_READ,
  RELATION_WRITE: RELATION_WRITE,
  RESOURCE_READ: RESOURCE_READ,
  RESOURCE_WRITE: RESOURCE_WRITE,
  RUN_AS: RUN_AS,
  SEARCH: SEARCH,
  SEQUENCE_READ: SEQUENCE_READ,
  SEQUENCE_WRITE: SEQUENCE_WRITE,
  SHAPE_TAG_READ: SHAPE_TAG_READ,
  SHAPE_TAG_WRITE: SHAPE_TAG_WRITE,
  SITE_MANAGER: SITE_MANAGER,
  SITE_RULE_READ: SITE_RULE_READ,
  SITE_RULE_WRITE: SITE_RULE_WRITE,
  STORAGE_GROUP_READ: STORAGE_GROUP_READ,
  STORAGE_GROUP_WRITE: STORAGE_GROUP_WRITE,
  STORAGE_NOTIFICATION_READ: STORAGE_NOTIFICATION_READ,
  STORAGE_NOTIFICATION_WRITE: STORAGE_NOTIFICATION_WRITE,
  STORAGE_READ: STORAGE_READ,
  STORAGE_RULE_READ: STORAGE_RULE_READ,
  STORAGE_RULE_WRITE: STORAGE_RULE_WRITE,
  STORAGE_WRITE: STORAGE_WRITE,
  SUPER_ACCESS_USER: SUPER_ACCESS_USER,
  TASKDEFINITION_READ: TASKDEFINITION_READ,
  TASKDEFINITION_WRITE: TASKDEFINITION_WRITE,
  THUMBNAIL_READ: THUMBNAIL_READ,
  THUMBNAIL_WRITE: THUMBNAIL_WRITE,
  TRANSCODER: TRANSCODER,
  TRANSFER_READ: TRANSFER_READ,
  TRANSFER_WRITE: TRANSFER_WRITE,
  USER: USER,
  VXA: VXA,
  VXA_READ: VXA_READ
});

var parseSimpleMetadataType = function parseSimpleMetadataType() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$field = _ref.field,
      field = _ref$field === void 0 ? [] : _ref$field;

  return parseKeyValuePairType(field);
};

var parseHighlightTimespan = function parseHighlightTimespan() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$field = _ref.field,
      field = _ref$field === void 0 ? [] : _ref$field,
      start = _ref.start,
      end = _ref.end;

  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts$arrayOnSingle = opts.arrayOnSingle,
      arrayOnSingle = _opts$arrayOnSingle === void 0 ? true : _opts$arrayOnSingle,
      _opts$joinValue = opts.joinValue,
      joinValue = _opts$joinValue === void 0 ? undefined : _opts$joinValue,
      _opts$timespanAsList = opts.timespanAsList,
      timespanAsList = _opts$timespanAsList === void 0 ? undefined : _opts$timespanAsList;
  var initialValue = timespanAsList ? {
    start: start,
    end: end
  } : {};
  var fieldList = field.reduce(function (a, _ref2) {
    var name = _ref2.name,
        _ref2$value = _ref2.value,
        valueList = _ref2$value === void 0 ? [] : _ref2$value;
    if (valueList.length === 0) return a;
    var fieldValue;

    if (arrayOnSingle === false && valueList.length === 1) {
      var _valueList = _slicedToArray(valueList, 1);

      fieldValue = _valueList[0];
    } else if (joinValue) fieldValue = valueList.join(joinValue);else fieldValue = valueList;

    return _objectSpread2(_objectSpread2({}, a), {}, _defineProperty({}, name, fieldValue));
  }, initialValue);
  return fieldList;
};
/**
 * Parses Highlight Timespans into key/value object.
 * The attributes can be targeted for each sub-type.
 * @param {Object} highlightTimespanList - A list of timespans.
 * @param {Object} options - Options which change how the timespans are parsed.
 * @param {Object} options.arrayOnSingle - Return an array if there is a single value.
 * @param {Object} options.joinValue - String to join the values, eg ','.
 * @param {Object} options.flat - Flatten to field-name/field-value (Note: field-values may be overwritten).
 * @param {Object} options.flatTimespan - Flatten timespan to object with start/end as key.
 * @param {Object} options.timespanAsList - Return timespans as list.
 * @param {Object} options.joinTimespan - String character to join the start/end timecodes.
 */


var parseHighlightTimespanList = function parseHighlightTimespanList() {
  var highlightTimespanList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var flat = opts.flat,
      timespanAsList = opts.timespanAsList,
      _opts$joinTimespan = opts.joinTimespan,
      joinTimespan = _opts$joinTimespan === void 0 ? '_' : _opts$joinTimespan,
      flatTimespan = opts.flatTimespan;
  if (timespanAsList === true) return highlightTimespanList.map(function (timespan) {
    return parseHighlightTimespan(timespan, opts);
  });
  if (flat === true || flatTimespan === true) return highlightTimespanList.reduce(function (a, timespan) {
    return _objectSpread2(_objectSpread2({}, a), parseHighlightTimespan(timespan, opts));
  }, {});
  return highlightTimespanList.reduce(function (a, timespan) {
    return _objectSpread2(_objectSpread2({}, a), {}, _defineProperty({}, [timespan.start, timespan.end].join(joinTimespan), parseHighlightTimespan(timespan, opts)));
  }, {});
};

var PDF = 'PDF';
var TEXT = 'TEXT';
var MSWORD = 'MSWORD';
var JSON$1 = 'JSON';
var XML = 'XML';

var getDocumentType = function getDocumentType() {
  var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var mimeType = shape.mimeType;
  if (!mimeType) return undefined;
  if (mimeType.endsWith('/pdf')) return PDF;
  if (mimeType.startsWith('text/')) return TEXT;
  if (mimeType.endsWith('/msword')) return MSWORD;
  if (mimeType.endsWith('/json')) return JSON$1;
  if (mimeType.endsWith('/xml')) return XML;
  return undefined;
};

exports.TimeBase = TimeBase;
exports.TimeCode = TimeCode;
exports.createFacetType = createFacetType;
exports.createMetadataType = createMetadataType;
exports.filterShapeSource = filterShapeSource;
exports.findNearestThumbnail = findNearestThumbnail;
exports.findTimespan = findTimespan;
exports.formatSeconds = formatSeconds;
exports.formatSecondsPrecise = formatSecondsPrecise;
exports.formatSmpte = formatSmpte;
exports.formatTimeBase = formatTimeBase;
exports.formatTimeBaseText = formatTimeBaseText;
exports.formatTimeBaseType = formatTimeBaseType;
exports.formatTimeCodeText = formatTimeCodeText;
exports.formatTimeCodeType = formatTimeCodeType;
exports.getDocumentType = getDocumentType;
exports.getShapeMediaType = getShapeMediaType;
exports.metadataTypeToWebVtt = metadataTypeToWebVtt;
exports.parseAspectRatio = parseAspectRatio;
exports.parseAudioComponent = parseAudioComponent;
exports.parseBaseMediaInfoType = parseBaseMediaInfoType;
exports.parseBinaryComponent = parseBinaryComponent;
exports.parseContainerComponent = parseContainerComponent;
exports.parseFacetType = parseFacetType;
exports.parseFileType = parseFileType;
exports.parseHighlightTimespan = parseHighlightTimespan;
exports.parseHighlightTimespanList = parseHighlightTimespanList;
exports.parseKeyValuePairType = parseKeyValuePairType;
exports.parseMediaConvertPreset = parseMediaConvertPreset;
exports.parseMetadataType = parseMetadataType;
exports.parseNowDate = parseNowDate;
exports.parseShapeType = parseShapeType;
exports.parseSimpleMetadataType = parseSimpleMetadataType;
exports.parseTimespan = parseTimespan;
exports.parseTimespanList = parseTimespanList;
exports.parseTranscodePreset = parseTranscodePreset;
exports.parseVideoComponent = parseVideoComponent;
exports.roles = roles;
exports.sortTimespanList = sortTimespanList;
//# sourceMappingURL=index.js.map
